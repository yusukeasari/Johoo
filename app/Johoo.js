// Generated by CoffeeScript 1.6.2
(function() {
  var Browser, ClickOnlyButton, ControlPanel, ControlPanelModel, PhotomosaicViewer, Point, Popup, Pyramid, SModel, SearchPanel, SearchResult, Shadow, Tile, TileView, Tiles, Timeline, TimelineChild, TimelineChildView, Utility, arrZoomSizeX, arrZoomSizeY, blockHeight, blockWidth, commentZoom, i, maxSearchResultNum, minBlockSize, minZoom, motifHeight, motifWidth, nowZoom, pinchTrigger, pinchTriggerArray, prevZoom, searchPhp, tileHeight, tileImageDir, tileImageExtension, tileWidth, tlImageWidth, z, zoomImageDir, zoomSize, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  tileWidth = 256;

  tileHeight = 256;

  blockWidth = 20;

  blockHeight = 20;

  minZoom = 1;

  commentZoom = false;

  motifWidth = 85;

  motifHeight = 120;

  pinchTrigger = 15;

  maxSearchResultNum = 50;

  searchPhp = 'swfData/search.php';

  tileImageDir = 'swfData/web/';

  zoomImageDir = 'swfData/blockimg/';

  tileImageExtension = '.jpg';

  minBlockSize = 1;

  arrZoomSizeX = [4, 4, 8, 16, 32, 64, 128, 256];

  arrZoomSizeY = [4, 4, 8, 16, 32, 64, 128, 256];

  tlImageWidth = 80;

  nowZoom = minZoom;

  prevZoom = minZoom;

  zoomSize = [[], [motifWidth * minBlockSize * arrZoomSizeX[1], motifHeight * minBlockSize * arrZoomSizeY[1]], [motifWidth * minBlockSize * arrZoomSizeX[2], motifHeight * minBlockSize * arrZoomSizeY[2]], [motifWidth * minBlockSize * arrZoomSizeX[3], motifHeight * minBlockSize * arrZoomSizeY[3]], [motifWidth * minBlockSize * arrZoomSizeX[4], motifHeight * minBlockSize * arrZoomSizeY[4]], [motifWidth * minBlockSize * arrZoomSizeX[5], motifHeight * minBlockSize * arrZoomSizeY[5]], [motifWidth * minBlockSize * arrZoomSizeX[6], motifHeight * minBlockSize * arrZoomSizeY[5]], [motifWidth * minBlockSize * arrZoomSizeX[7], motifHeight * minBlockSize * arrZoomSizeY[5]]];

  pinchTriggerArray = [];

  i = 1;

  for (_i = 0, _len = arrZoomSizeX.length; _i < _len; _i++) {
    z = arrZoomSizeX[_i];
    pinchTriggerArray.push(pinchTrigger * i);
    i++;
  }

  $(function() {
    var pmviewer;

    return pmviewer = new PhotomosaicViewer;
  });

  /**
   * Class PhotomosaicViewer メインクラス
   * 表示別にクラスを分けるようにすること
  */


  PhotomosaicViewer = (function(_super) {
    __extends(PhotomosaicViewer, _super);

    function PhotomosaicViewer() {
      _ref = PhotomosaicViewer.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    PhotomosaicViewer.prototype.initialize = function() {
      var _this = this;

      _.bindAll(this);
      this.smodel = new SModel;
      this.uniBrowse = new Browser;
      this.shadow = new Shadow;
      this.pyramid = new Pyramid;
      this.popup = new Popup;
      this.searchPanel = new SearchPanel;
      this.controlPanel = new ControlPanel;
      this.pyramid.bind('openPopupFromPoint', function(p) {
        return _this.popup.openPopupFromPoint(p);
      });
      this.searchPanel.bind('onclicktimeline', function(d) {
        SearchPanel.hide();
        Pyramid.show();
        ControlPanel.show();
        return _this.pyramid.moveToNum(d);
      });
      this.controlPanel.bind('change', function(h) {
        return _this.pyramid.update(h);
      });
      return this.controlPanel.bind('showSearchPanel', function() {
        SearchPanel.show();
        Pyramid.hide();
        return ControlPanel.hide();
      });
    };

    return PhotomosaicViewer;

  })(Backbone.View);

  /**
   * Class SModel 現在はイベント管理のみ
   *
  */


  SModel = (function(_super) {
    __extends(SModel, _super);

    function SModel() {
      this.removeEvent = __bind(this.removeEvent, this);
      this.setEvent = __bind(this.setEvent, this);      _ref1 = SModel.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SModel.prototype.setEvent = function(_target, _eventname) {
      var _this = this;

      return this.bind(_eventname, function(_data) {
        return _this.cEvent(_eventname, _data);
      });
    };

    SModel.prototype.removeEvent = function(_e) {
      return this.unbind(_e);
    };

    SModel.prototype.cEvent = function(_event, _data) {
      return this.trigger("" + _event + "R", _data);
    };

    return SModel;

  })(Backbone.Model);

  SearchPanel = (function(_super) {
    __extends(SearchPanel, _super);

    function SearchPanel() {
      this.clear = __bind(this.clear, this);
      this.error = __bind(this.error, this);
      this.onTapSubmitButton = __bind(this.onTapSubmitButton, this);
      this.loading = __bind(this.loading, this);
      this.bottom = __bind(this.bottom, this);      _ref2 = SearchPanel.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    SearchPanel.el = '#SearchPanel';

    SearchPanel.prototype.searchQuery = '';

    SearchPanel.timeline = '';

    SearchPanel.prototype.initialize = function() {
      var _clear,
        _this = this;

      _.bindAll(this);
      this.timeline = new Timeline;
      this.timeline.bind('add', this.appendTimeline);
      this.timeline.bind('onclicktimeline', this.onclicktimeline);
      this.searchQuery = new SearchResult;
      this.loadingStatus = false;
      this.execSearched = false;
      $(this.el).load("searchPanel.html", null, function(data, status) {
        if (status !== 'success') {
          return alert("ERROR:検索パネルが読み込めません");
        } else {
          $(SearchPanel.el).html(data);
          return _this.setup();
        }
      });
      return _clear = function() {
        _this.execSearched = false;
        return _this.clear();
      };
    };

    SearchPanel.prototype.onclicktimeline = function(d) {
      this.clear();
      this.trigger('onclicktimeline', d);
      return console.log("S onclicktimeline", d);
    };

    SearchPanel.prototype.appendTimeline = function(tile) {
      var timelineChildView;

      timelineChildView = new TimelineChildView({
        model: tile
      });
      return $("#searchResult").append(timelineChildView.render().el);
    };

    SearchPanel.prototype.setup = function() {
      var _this = this;

      $('#searchSubmitButton').css({
        width: 150,
        height: 30
      });
      $('#searchSubmitButton').bind('click', this.onTapSubmitButton);
      $(this.el).bind('bottom', this.bottom);
      return $(window).scroll(function() {
        if ($(document).height() < $(window).scrollTop() + Browser.height + 4 && _this.loadingStatus === false && _this.execSearched) {
          _this.loading(true);
          return $(_this.el).trigger('bottom');
        }
      });
    };

    SearchPanel.prototype.bottom = function() {
      var _this = this;

      return setTimeout(function() {
        return _this.sendQuery();
      }, 1500);
    };

    SearchPanel.prototype.loading = function(bool) {
      if (bool) {
        $('#loadingAnimation').html('');
        $('#loadingAnimation').append('<img src="img/loadingAnimation.gif">');
        return this.loadingStatus = bool;
      } else {
        $('#loadingAnimation').html('');
        $('#loadingAnimation').append('<span style="font-size:36px;">MORE RESULT</span>');
        return this.loadingStatus = bool;
      }
    };

    SearchPanel.prototype.onTapSubmitButton = function() {
      this.execSearched = true;
      this.clear();
      this.searchQuery.resetPageCount();
      return this.sendQuery();
    };

    SearchPanel.prototype.sendQuery = function() {
      var query,
        _this = this;

      query = '';
      this.searchQuery.unbind();
      this.searchQuery.bind('return', function(result) {
        return _this.render(result);
      });
      this.searchQuery.bind('error', function() {
        return _this.error;
      });
      if ($('#SearchPanelInnerContents #id').val() !== void 0) {
        query += 'id=' + $('#SearchPanelInnerContents #id').val() + '&';
      }
      if ($('#SearchPanelInnerContents #b1').val() !== void 0) {
        query += 'b1=' + $('#SearchPanelInnerContents #b1').val() + '&';
      }
      if ($('#SearchPanelInnerContents #b2').val() !== void 0) {
        query += 'b2=' + $('#SearchPanelInnerContents #b2').val() + '&';
      }
      if (query !== '') {
        query.slice(0, -1);
      }
      return this.searchQuery.sendQuery(query);
    };

    SearchPanel.prototype.error = function() {
      return this.loading(false);
    };

    SearchPanel.prototype.render = function(result) {
      var item, tlChild, _j, _len1;

      if (result !== "") {
        for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
          item = result[_j];
          tlChild = new TimelineChild;
          tlChild.set({
            data: item
          });
          this.timeline.add(tlChild);
        }
      } else {
        alert("「" + value + "」では見つかりませんでした。");
      }
      return this.loading(false);
    };

    SearchPanel.show = function() {
      SearchPanel._clear;
      Shadow.show();
      return $(SearchPanel.el).show();
    };

    SearchPanel.hide = function() {
      SearchPanel.execSearched = false;
      SearchPanel.loadingStatus = false;
      Shadow.hide();
      return $(SearchPanel.el).hide();
    };

    SearchPanel.prototype.clear = function() {
      this.execSearched = false;
      $('#loadingAnimation').html('');
      return this.timeline.clear();
    };

    return SearchPanel;

  }).call(this, Backbone.View);

  Timeline = (function(_super) {
    __extends(Timeline, _super);

    function Timeline() {
      _ref3 = Timeline.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    Timeline.prototype.model = TimelineChild;

    Timeline.prototype.clear = function() {
      return this.each(function(tlChild) {
        return tlChild.clear();
      });
    };

    return Timeline;

  })(Backbone.Collection);

  TimelineChild = (function(_super) {
    __extends(TimelineChild, _super);

    function TimelineChild() {
      _ref4 = TimelineChild.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    TimelineChild.prototype.defaults = {
      data: ''
    };

    TimelineChild.prototype.initialize = function() {
      return this.bind('onclicktimeline', this.onclicktimeline);
    };

    TimelineChild.prototype.clear = function() {
      this.unbind;
      this.destroy;
      return this.view.unrender();
    };

    return TimelineChild;

  })(Backbone.Model);

  TimelineChildView = (function(_super) {
    __extends(TimelineChildView, _super);

    function TimelineChildView() {
      this.onclicks = __bind(this.onclicks, this);
      this.unrender = __bind(this.unrender, this);
      this.render = __bind(this.render, this);      _ref5 = TimelineChildView.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    TimelineChildView.prototype.tagName = 'div';

    TimelineChildView.prototype.data = '';

    TimelineChildView.prototype.events = {
      "click": "onclicks"
    };

    TimelineChildView.prototype.initialize = function() {
      _.bindAll(this);
      return this.model.view = this;
    };

    TimelineChildView.prototype.render = function() {
      var item, tl;

      item = this.model.get('data');
      this.data = item;
      tl = $(this.el).attr('class', 'timelineChild').attr('id', 'timelineChild' + item.id);
      $('<img />').attr('class', 'tlImg').attr('width', tlImageWidth).attr('src', 'swfData/blockimg/' + item.img + '.jpg').load().appendTo(tl);
      $('<div />').attr('class', 'tlTitle').html(item.b1).appendTo(tl);
      $('<br />').appendTo(tl);
      $('<div />').attr('class', 'tlMsg').html(item.b2).appendTo(tl);
      $('<br />').attr('class', 'timelineBR').appendTo(tl);
      return this;
    };

    TimelineChildView.prototype.unrender = function() {
      $(this.el).remove();
      return $(this.el).unbind();
    };

    TimelineChildView.prototype.onclicks = function() {
      return this.model.trigger('onclicktimeline', this.data.num);
    };

    return TimelineChildView;

  })(Backbone.View);

  SearchResult = (function(_super) {
    __extends(SearchResult, _super);

    function SearchResult() {
      this.nextPage = __bind(this.nextPage, this);
      this.resetPageCount = __bind(this.resetPageCount, this);
      this.queryResult = __bind(this.queryResult, this);
      this.sendQuery = __bind(this.sendQuery, this);      _ref6 = SearchResult.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    SearchResult.prototype.page = 1;

    SearchResult.prototype.linePerPage = 30;

    SearchResult.prototype.sendQuery = function(query) {
      var _this = this;

      return $.ajax("timeline.json", {
        type: "GET",
        dataType: "json",
        error: function(jqXHR, textStatus, errorThrown) {
          return this.trigger('error');
        },
        success: function(data) {
          return _this.queryResult(data);
        }
      });
    };

    SearchResult.prototype.queryResult = function(result) {
      return this.trigger('return', result);
    };

    SearchResult.prototype.resetPageCount = function() {
      return this.page = 1;
    };

    SearchResult.prototype.nextPage = function() {
      return this.page++;
    };

    return SearchResult;

  })(Backbone.View);

  /**
   * Class Browser 環境設定関連
   * ブラウザチェック、それにあわせた描画領域の設定、アドレスバーを隠す等
   * 完成したらちゃんと書く
  */


  Browser = (function(_super) {
    __extends(Browser, _super);

    function Browser() {
      _ref7 = Browser.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    Browser.device = '';

    Browser.os = '';

    Browser.width = 0;

    Browser.height = 0;

    Browser.orient = 0;

    Browser.prototype.initialize = function() {
      _.bindAll(this);
      $(window).bind("orientationchange resize", this.setup);
      return this.setup();
    };

    Browser.prototype.setup = function() {
      if (navigator.userAgent.match(/iPhone/i || navigator.userAgent.match(/iPod/i))) {
        Browser.device = 'smartphone';
        Browser.os = 'ios';
        Browser.version = '';
        Browser.width = Math.abs(window.orientation !== 90) ? screen.width : screen.height;
        Browser.height = Math.abs(window.orientation !== 90) ? screen.height - 64 : screen.width - 52;
      } else if (navigator.userAgent.match(/iPad/i)) {
        Browser.device = 'tablet';
        Browser.os = 'ios';
        Browser.version = '';
      } else if (navigator.userAgent.match(/Android/i && navigator.userAgent.match(/Mobile/i))) {
        Browser.device = 'smartphone';
        Browser.os = 'android';
        Browser.version = '';
        Browser.width = screen.width;
        Browser.height = screen.height;
      } else if (navigator.userAgent.match(/Android/i && !navigator.userAgent.match(/Mobile/i))) {
        Browser.device = 'tablet';
        Browser.os = 'android';
        Browser.version = '';
        Browser.width = screen.width;
        Browser.height = screen.height;
      } else {
        Browser.device = 'pc';
        Browser.width = screen.width / 2;
        Browser.height = screen.height / 2;
      }
      $('#Pyramid').width(Browser.width);
      $('#Pyramid').height(Browser.height);
      return this.hideAddressBar();
    };

    Browser.prototype.hideAddressBar = function() {
      if (Browser.getOS() === 'ios') {
        return setTimeout(scrollTo, 100, 0, 1);
      } else if (Browser.getOS() === 'android') {
        return window.scrollTo(0, 1);
      }
    };

    Browser.getDevice = function() {
      return Browser.device;
    };

    Browser.getOS = function() {
      return Browser.os;
    };

    return Browser;

  }).call(this, Backbone.View);

  Utility = (function() {
    function Utility() {}

    Utility.type = (function() {
      var classToType, name, _j, _len1, _ref8;

      classToType = {};
      _ref8 = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
      for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
        name = _ref8[_j];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      return function(obj) {
        var strType;

        strType = Object.prototype.toString.call(obj);
        return classToType[strType] || "object";
      };
    })();

    return Utility;

  })();

  /**
   * Class Pyramidクラス
  */


  Pyramid = (function(_super) {
    __extends(Pyramid, _super);

    function Pyramid() {
      _ref8 = Pyramid.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    Pyramid.prototype.el = "#Tiles";

    Pyramid.outerel = '#Pyramid';

    /*
    	初期化メソッド
    */


    Pyramid.prototype.initialize = function() {
      _.bindAll(this);
      if (Browser.device !== 'pc') {
        $(this.el).bind('touchstart', this.onMouseDown);
        $(this.el).bind('touchend', this.onMouseUp);
        $(this.el).bind('touchmove', this.onMouseMove);
      } else {
        $(this.el).bind('mousedown', this.onMouseDown);
        $(this.el).bind('mouseup', this.onMouseUp);
        $(this.el).bind('mousemove', this.onMouseMove);
      }
      $(this.el).flickable();
      this.dragging = false;
      this.tiles = new Tiles;
      this.tiles.bind('add', this.appendTile);
      this.tiles.bind('change', this.changeTile);
      $(this.el).css({
        'cursor': '-moz-grab'
      });
      this.update();
      return this.pyramidSetPositionToCenter();
    };

    Pyramid.show = function() {
      return $(this.outerel).show();
    };

    Pyramid.hide = function() {
      return $(this.outerel).hide();
    };

    /*
    	マウスイベント関連メソッド群
    */


    Pyramid.prototype.onMouseDown = function(e) {
      var cords;

      cords = Point.getPoint(e);
      e.preventDefault();
      this.dragging = true;
      if (Utility.type(cords[0]) !== 'array') {
        $(this.el).css({
          'cursor': '-moz-grab'
        });
        this.dragStartX = cords[0];
        this.dragStartY = cords[1];
        this.dragStartPyramidX = this.getPyramidPos()[0];
        return this.dragStartPyramidY = this.getPyramidPos()[1];
      } else {
        $(this.el).css({
          'cursor': '-moz-grab'
        });
        this.dragStartX = cords[0][0];
        this.dragStartY = cords[0][1];
        this.dragStartPyramidX = this.getPyramidPos()[0];
        return this.dragStartPyramidY = this.getPyramidPos()[1];
      }
      /*
      		else if Utility.type(cords[0]) is 'array'
      			$(@el).css {'cursor':'-moz-grab'}
      			@pinchinStartCenterX = (cords[0][0] + cords[1][0])/2
      			@pinchinStartCenterY = (cords[0][1] + cords[1][1])/2
      
      			@pinchinStart = cords
      */

    };

    Pyramid.prototype.onMouseUp = function(e) {
      var cords;

      cords = Point.getPoint(e);
      e.preventDefault();
      this.dragging = false;
      console.log(cords);
      $(this.el).css({
        'cursor': ''
      });
      if (this.dragStartX === cords[0] && this.dragStartY === cords[1] && this.isOnTiles([cords[0], cords[1]])) {
        if (!Shadow.isShow()) {
          return this.trigger('openPopupFromPoint', this.getNumFromPoint([cords[0], cords[1]]));
        }
      } else if (this.dragStartX === cords[0][0] && this.dragStartY === cords[0][1] && this.isOnTiles([cords[0][0], cords[0][1]])) {
        if (!Shadow.isShow()) {
          return this.trigger('openPopupFromPoint', this.getNumFromPoint([cords[0][0], cords[0][1]]));
        }
      } else {
        return this.update();
      }
    };

    Pyramid.prototype.onMouseMove = function(e) {
      var cords;

      cords = Point.getPoint(e);
      e.preventDefault();
      if (Utility.type(cords[0]) === "number" && this.dragging === true) {
        return $(this.el).css({
          'left': this.dragStartPyramidX + (this.getMousePos(e)[0] - this.dragStartX),
          'top': this.dragStartPyramidY + (this.getMousePos(e)[1] - this.dragStartY)
        });
      } else if (Utility.type(cords[0]) === "array" && this.dragging === true) {

      } else {

      }
    };

    Pyramid.prototype.onGestureStart = function(e) {
      return console.log(e.originalEvent.scale);
    };

    Pyramid.prototype.onGestureMove = function(e) {
      if (e.originalEvent.scale > 1) {
        return this.zoomIn(e.originalEvent.scale);
      } else {
        return this.zoomOut(e.originalEvent.scale);
      }
    };

    Pyramid.prototype.onGestureEnd = function(e) {
      return console.log(e.originalEvent.scale);
    };

    Pyramid.prototype.zoomIn = function(_z) {
      var rate;

      rate = Math.floor(_z / 2);
      console.log("plus", rate, nowZoom);
      if (nowZoom < zoomSize.length - 1) {
        prevZoom = nowZoom;
        if (nowZoom + rate < zoomSize.length - 1) {
          nowZoom = nowZoom + rate;
        } else {
          nowZoom = zoomSize.length - 1;
        }
        if (nowZoom !== prevZoom) {
          return this.update('pinchZoomIn');
        }
      }
    };

    Pyramid.prototype.zoomOut = function(_z) {
      var rate;

      _z = (_z - 1) * 10;
      rate = Math.floor(_z / 2);
      console.log("minus:", rate, nowZoom);
      if (nowZoom > minZoom) {
        prevZoom = nowZoom;
        if (nowZoom - rate > minZoom) {
          nowZoom = minZoom;
        } else {
          nowZoom = nowZoom + rate;
        }
        if (nowZoom !== prevZoom) {
          return this.update('pinchZoomOut');
        }
      }
    };

    Pyramid.prototype.isOnTiles = function(p) {
      if (p[0] >= this.getPyramidPos()[0] && p[1] >= this.getPyramidPos()[1] && p[0] <= zoomSize[nowZoom][0] + this.getPyramidPos()[0] && p[1] <= parseInt(zoomSize[nowZoom][1]) + this.getPyramidPos()[1]) {
        return true;
      } else {
        return false;
      }
    };

    Pyramid.prototype.getNumFromPoint = function(p) {
      var xb, yb;

      xb = Math.floor((p[0] - this.getPyramidPos()[0]) / arrZoomSizeX[nowZoom]);
      yb = Math.round((p[1] - this.getPyramidPos()[1]) / arrZoomSizeY[nowZoom]);
      yb = yb === 0 || yb === 1 ? 0 : yb - 1;
      xb++;
      return motifWidth * yb + xb;
    };

    /**
    	 * 描画範囲調査メソッド
    	 * もっとスマートに出来たらなぁといつも思う
    */


    Pyramid.prototype.checkActiveTile = function() {
      var displayAreaEndX, displayAreaEndY, displayAreaStartX, displayAreaStartY, loadEndX, loadEndY, loadStartX, loadStartY;

      displayAreaStartX = this.getPyramidPos()[0] > 0 && Browser.width - Math.abs(this.getPyramidPos()[0]) > 0 ? 0 : Math.abs(this.getPyramidPos()[0]);
      displayAreaStartY = this.getPyramidPos()[1] > 0 && Browser.height - Math.abs(this.getPyramidPos()[1]) > 0 ? 0 : Math.abs(this.getPyramidPos()[1]);
      displayAreaEndX = this.getPyramidPos()[0] + zoomSize[nowZoom][0] > $('#Pyramid').width() ? $('#Pyramid').width() - this.getPyramidPos()[0] : zoomSize[nowZoom][0];
      displayAreaEndY = this.getPyramidPos()[1] + zoomSize[nowZoom][1] > $('#Pyramid').height() ? $('#Pyramid').height() - this.getPyramidPos()[1] : zoomSize[nowZoom][1];
      if (displayAreaEndX <= 0) {
        displayAreaEndX = 0;
      }
      if (displayAreaEndY <= 0) {
        displayAreaEndY = 0;
      }
      loadStartX = Math.floor(displayAreaStartX / tileWidth);
      loadStartY = Math.floor(displayAreaStartY / tileHeight);
      loadEndX = Math.floor(displayAreaEndX / tileWidth);
      loadEndY = Math.floor(displayAreaEndY / tileHeight);
      return [loadStartX, loadStartY, loadEndX, loadEndY];
    };

    /**
    	 * 描画メソッド
    	 * @param {startX} Number
    	 * @param {startY} Number
    	 * @param {endX} Number
    	 * @param {endY} Number
    */


    Pyramid.prototype.render = function(t) {
      var tile, x, x2, y, y2;

      x = t[0];
      y = t[1];
      x2 = t[2];
      y2 = t[3];
      this.tiles.removeAllTiles();
      while (y <= t[3]) {
        while (x <= t[2]) {
          if (!this.tiles.isSameTile(nowZoom, x, y)) {
            tile = new Tile;
            tile.set({
              x: x,
              y: y,
              z: nowZoom,
              display: true
            });
            this.tiles.add(tile);
          }
          x++;
        }
        y++;
        x = t[0];
      }
      return y = t[1];
    };

    /**
    	 * イベントコールバック用
    */


    Pyramid.prototype.update = function(h) {
      switch (h) {
        case 'zoomIn':
          this.moveToZoomInPos();
          break;
        case 'zoomOut':
          this.moveToZoomOutPos();
          break;
        case 'pinchZoomIn':
          this.moveToPinchZoomInPos();
          break;
        case 'pinchZoomOut':
          this.moveToPinchZoomOutPos();
          break;
      }
      $(this.el).width(zoomSize[nowZoom][0]);
      $(this.el).height(zoomSize[nowZoom][1]);
      return this.render(this.checkActiveTile());
    };

    Pyramid.prototype.moveToNum = function(d) {
      /*
      		xb = Math.floor (p[0]-@getPyramidPos()[0])/arrZoomSizeX[nowZoom]
      		yb = Math.round (p[1]-@getPyramidPos()[1])/arrZoomSizeY[nowZoom]
      		yb = if yb is 0 or yb is 1 then 0 else yb-1
      		xb++;
      		
      		motifWidth*yb+xb
      */

      var tx, ty,
        _this = this;

      tx = d % 56 * arrZoomSizeX[nowZoom] * -1;
      ty = Math.floor(d / 56) * arrZoomSizeX[nowZoom] * -1;
      console.log(tx, ty);
      $(this.el).css({
        left: (Browser.width / 2) + tx,
        top: (Browser.height / 2) + ty
      });
      return setTimeout(function() {
        return _this.update('');
      }, 500);
    };

    Pyramid.prototype.moveToPinchZoomInPos = function() {
      return $(this.el).css({
        left: $(this.el).position().left + this.pinchinStartCenterX * -1,
        top: $(this.el).position().top + this.pinchinStartCenterY * -1
      });
    };

    Pyramid.prototype.moveToPinchZoomOutPos = function() {
      return $(this.el).css({
        left: $(this.el).position().left + this.pinchinStartCenterX / 2,
        top: $(this.el).position().top + this.pinchinStartCenterY / 2
      });
    };

    Pyramid.prototype.moveToZoomInPos = function() {
      var newPyramidPos, pyramidPos;

      pyramidPos = this.convertToGrobalCenterPos($(this.el).position().left, $(this.el).position().top);
      if (nowZoom !== zoomSize.length - 1 && commentZoom === true) {
        newPyramidPos = this.convertToLocalCenterPos(pyramidPos[0], pyramidPos[1]);
      } else {
        newPyramidPos = this.convertToLocalCenterPos(pyramidPos[0] * 2, pyramidPos[1] * 2);
      }
      return $(this.el).css({
        left: newPyramidPos[0],
        top: newPyramidPos[1]
      });
    };

    Pyramid.prototype.moveToZoomOutPos = function() {
      var newPyramidPos, pyramidPos;

      pyramidPos = this.convertToGrobalCenterPos($(this.el).position().left, $(this.el).position().top);
      if (prevZoom !== 8) {
        newPyramidPos = this.convertToLocalCenterPos(pyramidPos[0] / 2, pyramidPos[1] / 2);
      } else if (prevZoom === 8) {
        newPyramidPos = this.convertToLocalCenterPos(pyramidPos[0], pyramidPos[1]);
      } else {
        newPyramidPos = this.convertToLocalCenterPos(pyramidPos[0] / 2, pyramidPos[1] / 2);
      }
      return $(this.el).css({
        left: newPyramidPos[0],
        top: newPyramidPos[1]
      });
    };

    Pyramid.prototype.convertToGrobalCenterPos = function(_x, _y) {
      var prevPyramidHeight, prevPyramidWidth, x, y;

      if (nowZoom !== 1 || prevZoom === zoomSize.length - 1) {
        console.log("GROBAL", arrZoomSizeX[nowZoom], arrZoomSizeY[nowZoom], nowZoom);
        prevPyramidWidth = zoomSize[prevZoom][0];
        prevPyramidHeight = zoomSize[prevZoom][1];
      } else {
        prevPyramidWidth = zoomSize[prevZoom][0];
        prevPyramidHeight = zoomSize[prevZoom][1];
      }
      x = (_x + prevPyramidWidth / 2) - Browser.width / 2;
      y = (_y + prevPyramidHeight / 2) - Browser.height / 2;
      return [x, y];
    };

    Pyramid.prototype.convertToLocalCenterPos = function(_x, _y) {
      var nowPyramidHeight, nowPyramidWidth, x, y;

      console.log("convertToLocalCenterPos", _x, _y);
      nowPyramidWidth = zoomSize[nowZoom][0];
      nowPyramidHeight = zoomSize[nowZoom][1];
      x = _x - nowPyramidWidth / 2 + Browser.width / 2;
      y = _y - nowPyramidHeight / 2 + Browser.height / 2;
      return [x, y];
    };

    /*
    	 * addイベントのコールバックメソッド
    	 * 原則としてcollectionへbindする事
    	 * @param {tile} Tile
    */


    Pyramid.prototype.appendTile = function(tile) {
      var tileView;

      tileView = new TileView({
        model: tile
      });
      return $(this.el).append(tileView.render().el);
    };

    /*
    	Pyramid位置操作メソッド群
    */


    Pyramid.prototype.pyramidSetPositionToCenter = function() {
      return $(this.el).css({
        left: Browser.width / 2 - zoomSize[nowZoom][0] / 2,
        top: Browser.height / 2 - zoomSize[nowZoom][1] / 2
      });
    };

    /*
    	 * 位置取得メソッド群
    	 * 基本はreturnする簡単なお仕事
    	 * @param {e} Event
    */


    Pyramid.prototype.getMousePos = function(e) {
      var cords;

      cords = Point.getPoint(e);
      return [cords[0], cords[1]];
    };

    Pyramid.prototype.getPyramidPos = function() {
      return [$(this.el).position().left, $(this.el).position().top];
    };

    return Pyramid;

  })(Backbone.View);

  /**
   * Tileクラス
   * Tile画像に必要な情報のみ保持するModelクラス
   * @param {x} Number
   * @param {y} Number
   * @param {z} Number
   * @param {display} Boolean
  */


  Tile = (function(_super) {
    __extends(Tile, _super);

    function Tile() {
      _ref9 = Tile.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    Tile.prototype.defaults = {
      x: 0,
      y: 0,
      z: 0,
      display: false
    };

    Tile.prototype.clear = function() {
      this.destroy;
      return this.view.unrender();
    };

    return Tile;

  })(Backbone.Model);

  /**
   * Class TileViewクラス Tile画像を描画したり削除する役割のみ
  */


  TileView = (function(_super) {
    __extends(TileView, _super);

    function TileView() {
      this.unrender = __bind(this.unrender, this);
      this.render = __bind(this.render, this);      _ref10 = TileView.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    TileView.prototype.tagName = 'img';

    TileView.prototype.initialize = function() {
      _.bindAll(this);
      return this.model.view = this;
    };

    TileView.prototype.render = function() {
      var url, x, y;

      x = this.model.get('x');
      y = this.model.get('y');
      z = this.model.get('z');
      url = tileImageDir + ("" + z + "/" + y + "/") + 'z' + z + 'x' + x + 'y' + y + tileImageExtension;
      $(this.el).attr({
        id: 'z' + z + 'x' + x + 'y' + y,
        src: url
      }).css({
        'position': 'absolute',
        'left': x * tileWidth,
        'top': y * tileWidth
      }).load();
      return this;
    };

    TileView.prototype.unrender = function() {
      return $(this.el).remove();
    };

    return TileView;

  })(Backbone.View);

  /**
   * Class Tiles Tileクラスを管理する役割。描画に関してのイベント管理とか。イベントの割り当ては原則、Pyramidクラスで行う
  */


  Tiles = (function(_super) {
    __extends(Tiles, _super);

    function Tiles() {
      _ref11 = Tiles.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    Tiles.prototype.model = Tile;

    Tiles.prototype.initialize = function() {
      return _.bindAll(this);
    };

    Tiles.prototype.isSameTile = function(_z, _x, _y) {
      var data, item, res, _j, _len1;

      data = [];
      this.each(function(tile) {
        return data.push(tile);
      });
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        item = data[_j];
        if (("" + (item.get('z')) + " " + (item.get('x')) + " " + (item.get('y'))) === ("" + _z + " " + _x + " " + _y)) {
          res = true;
        } else {
          res = false;
        }
      }
      return res;
    };

    Tiles.prototype.getNowVisibleList = function() {
      var data;

      data = [];
      this.each(function(tile) {
        return data.push(tile);
      });
      return data;
    };

    Tiles.prototype.setRemove = function() {
      var data;

      data = [];
      return this.each(function(tile) {
        return data.push(tile);
      });
    };

    Tiles.prototype.removeCheckedTiles = function() {
      var tile, _j, _len1, _results;

      _results = [];
      for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
        tile = data[_j];
        if (tile.get('display' !== true)) {
          _results.push(tile.clear());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Tiles.prototype.removeAllTiles = function() {
      return this.each(function(tile) {
        return tile.clear();
      });
    };

    return Tiles;

  })(Backbone.Collection);

  /**
   * Class ControlPanel コンパネに表示するボタンとか管理
  */


  ControlPanel = (function(_super) {
    __extends(ControlPanel, _super);

    function ControlPanel() {
      _ref12 = ControlPanel.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    ControlPanel.el = '#ControlPanel';

    ControlPanel.prototype.initialize = function() {
      var showSearchPanelButton, showTLPanelButton, zoomInButton, zoomOutButton;

      _.bindAll(this);
      zoomInButton = new ClickOnlyButton('#ZoomInButton');
      zoomInButton.bind('change', this.zoomIn);
      zoomOutButton = new ClickOnlyButton('#ZoomOutButton');
      zoomOutButton.bind('change', this.zoomOut);
      showSearchPanelButton = new ClickOnlyButton('#SearchPanelButton');
      showSearchPanelButton.bind('change', this.showSearchPanel);
      showTLPanelButton = new ClickOnlyButton('#TimelineButton');
      return showTLPanelButton.bind('change', this.showTLPanel);
    };

    ControlPanel.prototype.zoomIn = function() {
      if (nowZoom < zoomSize.length - 1) {
        prevZoom = nowZoom;
        nowZoom++;
        return this.trigger('change', 'zoomIn');
      }
    };

    ControlPanel.prototype.zoomOut = function() {
      if (nowZoom > minZoom) {
        prevZoom = nowZoom;
        nowZoom--;
        return this.trigger('change', 'zoomOut');
      }
    };

    ControlPanel.prototype.showSearchPanel = function() {
      return this.trigger('showSearchPanel');
    };

    ControlPanel.prototype.showTLPanel = function() {};

    ControlPanel.show = function() {
      return $(ControlPanel.el).show();
    };

    ControlPanel.hide = function() {
      return $(ControlPanel.el).hide();
    };

    return ControlPanel;

  }).call(this, Backbone.View);

  ControlPanelModel = (function(_super) {
    __extends(ControlPanelModel, _super);

    function ControlPanelModel() {
      _ref13 = ControlPanelModel.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    return ControlPanelModel;

  })(Backbone.Model);

  /**
   * Class ClickOnlyButton 汎用ボタンクラス。クラス名はちょっと考えたい。
   * @param div 描画用DOM
  */


  ClickOnlyButton = (function(_super) {
    __extends(ClickOnlyButton, _super);

    function ClickOnlyButton() {
      _ref14 = ClickOnlyButton.__super__.constructor.apply(this, arguments);
      return _ref14;
    }

    ClickOnlyButton.prototype.el = '';

    ClickOnlyButton.prototype.initialize = function(_el) {
      _.bindAll(this);
      this.el = _el;
      return $(this.el).bind("mouseup touchend", this.onMouseUp);
    };

    ClickOnlyButton.prototype.onMouseUp = function(e) {
      e.preventDefault();
      return this.trigger('change');
    };

    ClickOnlyButton.prototype.destroy = function() {
      $(this.el).unbind();
      return $(this.el).remove();
    };

    return ClickOnlyButton;

  })(Backbone.View);

  /**
   * Class Point イベントオブジェクトを受け取って座標を返すクラス。デバイス・ブラウザ問わずが基本思想
   * @param event マウスイベントオブジェクト
  */


  Point = (function() {
    function Point() {}

    Point.getPoint = function(e) {
      var cords, item, _j, _len1, _ref15;

      if (Point.isTouch()) {
        if (e.originalEvent.touches.length === 1) {
          console.log("SINGLE", e.originalEvent.touches[0].pageX, e.originalEvent.touches[0].pageY);
          return [e.originalEvent.touches[0].pageX, e.originalEvent.touches[0].pageY];
        } else if (e.originalEvent.touches.length > 1) {
          console.log("MULTI", e.originalEvent.touches);
          cords = [];
          _ref15 = e.originalEvent.touches;
          for (_j = 0, _len1 = _ref15.length; _j < _len1; _j++) {
            item = _ref15[_j];
            console.log(item.pageX, item.pageY);
            cords.push([item.pageX, item.pageY]);
          }
          return cords;
        } else {
          console.log("SINGLE", e.originalEvent);
          return [e.originalEvent.changedTouches[0].pageX, e.originalEvent.changedTouches[0].pageY];
        }
      } else {
        return [e.pageX, e.pageY];
      }
    };

    Point.isTouch = function() {
      return 'ontouchstart' in window;
    };

    return Point;

  })();

  Shadow = (function(_super) {
    __extends(Shadow, _super);

    function Shadow() {
      _ref15 = Shadow.__super__.constructor.apply(this, arguments);
      return _ref15;
    }

    Shadow.el = '#Shadow';

    Shadow.prototype.initialize = function() {
      return $(window).bind("load resize orientationchange", this.resize);
    };

    Shadow.show = function() {
      Shadow.setSize();
      return $(Shadow.el).show();
    };

    Shadow.hide = function() {
      Shadow.setSize();
      return $(Shadow.el).hide();
    };

    Shadow.prototype.resize = function() {
      return Shadow.setSize();
    };

    Shadow.setSize = function() {
      $(this.el).width(Browser.width);
      return $(this.el).height(Browser.height);
    };

    Shadow.isShow = function() {
      var res;

      res = $(Shadow.el).css('display');
      if (res === 'none') {
        return false;
      } else {
        return true;
      }
    };

    return Shadow;

  }).call(this, Backbone.View);

  Popup = (function(_super) {
    __extends(Popup, _super);

    function Popup() {
      _ref16 = Popup.__super__.constructor.apply(this, arguments);
      return _ref16;
    }

    Popup.el = '#Popup';

    Popup.prototype.initialize = function() {
      _.bindAll(this);
      return $(window).bind("resize orientationchange", this.resize);
    };

    Popup.prototype.openPopupFromPoint = function(p) {
      return $.getJSON(searchPhp, {
        'n': p
      }, function(data, status) {
        if (status && data !== null) {
          return Popup.render(data[0]);
        }
      });
    };

    Popup.clear = function() {
      if ($(Popup.el).html() !== '') {
        $("#closeButton").unbind();
        return $(Popup.el).html('');
      }
    };

    Popup.closePopup = function(e) {
      if (e !== void 0) {
        e.stopPropagation();
        e.preventDefault();
      }
      Popup.clear();
      return Popup.hide();
    };

    Popup.render = function(data) {
      Popup.show();
      return $('<img />').css('margin-top', 5).attr('src', zoomImageDir + data.img + '.jpg').load(function() {
        $('<div />').attr('id', 'popupOuterText').appendTo($(Popup.el));
        $("#popupOuterText").css({
          'width': '80%',
          'margin': 'auto'
        });
        $('<p>').attr('class', 'popupB1Style').text(data.b1).appendTo($(Popup.el));
        $('<p>').attr('class', 'popupB2Style').text(data.b2).appendTo($(Popup.el));
        return $('<img>').attr('id', 'closeButton').attr('src', 'assets/buttons/close.png').load(function() {
          return Popup.onClick();
        }).appendTo($(Popup.el));
      }).error(function() {
        return Popup.closePopup();
      }).appendTo($(this.el));
    };

    Popup.onClick = function() {
      return $("#closeButton").bind("touchend mouseup", function(e) {
        e.stopPropagation();
        e.preventDefault();
        return Popup.closePopup();
      });
    };

    Popup.show = function() {
      Shadow.setSize();
      $(Popup.el).show();
      return Shadow.show();
    };

    Popup.hide = function() {
      Shadow.setSize();
      $(Popup.el).hide();
      return Shadow.hide();
    };

    Popup.prototype.resize = function() {
      return Shadow.setSize();
    };

    Popup.setSize = function() {
      $(this.el).width(Browser.width);
      return $(this.el).height(Browser.height);
    };

    Popup.prototype.resize = function() {};

    return Popup;

  }).call(this, Backbone.View);

}).call(this);
